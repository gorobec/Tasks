01:30:54 [user] > Hi
01:30:59 [z] > hello
02:11:38 [gorobec] > ff
02:12:01  > [user] leave chatroom
11:58:57  > null leave chatroom
11:59:44  > null leave chatroom
12:01:18 [Kolya] > Hello!!
12:01:33 [admin] > Hi!
12:02:18  > [Kolya] leave chatroom
17:51:41 [user] > hello
17:51:49 [admin] > Hi
17:52:25 [gorobec] > ffgh
17:53:11  > [admin] leave chatroom
17:57:56 [admin] > Hello from swing!
18:00:56  > [user] leave chatroom
18:01:17  > [admin] leave chatroom
18:01:51 [admin] > 1
18:01:58 [admin] > 2
18:02:01 [admin] > 3
18:02:06 [admin] > 4
18:02:22  > [admin] leave chatroom
18:09:45 [admin] > jgjgjgjg
18:09:47 [admin] > 
18:09:47 [admin] > gmgmgmg
18:09:50 [admin] > 
18:09:50 [admin] > gmgmgmg
18:09:52 [admin] > 
18:09:52 [admin] > gmgmgm
18:09:53 [admin] > 
18:09:53 [admin] > gmgm
18:09:54 [admin] > 
18:09:54 [admin] > gmgm
18:09:55 [admin] > 
18:09:55 [admin] > gmgmg
18:09:56 [admin] > 
18:09:56 [admin] > gmgm
18:09:57 [admin] > 
18:09:57 [admin] > gmgm
18:10:03 [admin] > 
18:10:03 [admin] > gmgmg
18:10:18 [admin] > mgmgmg
18:10:21 [admin] > f,f,f,
18:10:24 [admin] > f,f,f
18:10:26 [admin] > f
18:10:33 [admin] > fff
18:10:34 [admin] > 
18:10:34 [admin] > fff
18:10:36 [admin] > 
18:10:36 [admin] > fff
18:10:38 [admin] > 
18:10:38 [admin] > ffff
18:10:45  > [admin] leave chatroom
18:11:24 [admin] > dfdfdf
18:11:28 [admin] > dfdf
18:11:32 [admin] > dfdf
18:11:36 [admin] > dfdf
18:11:38 [admin] > 
18:11:38 [admin] > fdfdf
18:11:43 [admin] > fdf
18:11:44 [admin] > 
18:11:44 [admin] > dfdf
18:11:46 [admin] > 
18:11:46 [admin] > dfdf
18:11:47 [admin] > 
18:11:47 [admin] > df
18:11:47 [admin] > 
18:11:47 [admin] > df
18:11:48 [admin] > 
18:11:48 [admin] > df
18:11:50 [admin] > 
18:11:50 [admin] > d
18:11:51 [admin] > 
18:11:51 [admin] > d
18:13:07  > [admin] leave chatroom
18:13:18  > null leave chatroom
18:13:49 [admin] > 1
18:13:50 [admin] > 
18:13:50 [admin] > 1
18:14:05  > [admin] leave chatroom
18:14:29 [admin] > dd
18:14:30 [admin] > 
18:14:30 [admin] > ddd
18:14:34 [admin] > 
18:14:34 [admin] > ddd
18:14:35 [admin] > 
18:14:35 [admin] > ddd
18:14:36 [admin] > 
18:14:36 [admin] > dd
18:14:36 [admin] > 
18:14:36 [admin] > d
18:14:36 [admin] > 
18:14:36 [admin] > d
18:14:38 [admin] > 
18:14:38 [admin] > d
18:15:57  > [admin] leave chatroom
18:16:14 [admin] > djdjdj
18:16:14 [admin] > dksldk
18:16:14 [admin] > skdlskd
18:18:24  > [admin] leave chatroom
18:18:40 [admin] > dsdsd
18:18:40 [admin] > dsd
18:18:43 [admin] > dsdsd
18:18:43 [admin] > dsd
18:18:43 [admin] > 
18:18:45 [admin] > dsdsd
18:18:45 [admin] > dsd
18:18:45 [admin] > 
18:18:45 [admin] > 
18:18:47 [admin] > dsdsd
18:18:47 [admin] > dsd
18:18:47 [admin] > 
18:18:47 [admin] > 
18:18:47 [admin] > 
18:18:52  > [admin] leave chatroom
18:19:32 [admin] > dfdf
18:19:34 [admin] > 
18:19:34 [admin] > fdf
18:19:35 [admin] > 
18:19:35 [admin] > dfdfdf
18:19:52  > [admin] leave chatroom
18:20:03 [admin] > admin
18:22:03  > [admin] leave chatroom
18:22:15 [admin] > dsd,dmds
18:22:17 [admin] > admin
18:22:17 [admin] > sdsddsmds
18:22:21 [admin] > admin
18:22:21 [admin] > cdcddv
18:22:33  > [admin] leave chatroom
18:26:29 [admin] > admin
18:26:29 [admin] > admin
18:26:29 [admin] > admin
18:26:31 [admin] > 
18:26:31 [admin] > d
18:26:33 [admin] > 
18:26:33 [admin] > d
18:27:01 [admin] > 
18:27:27  > [admin] leave chatroom
18:35:47  > [admin] leave chatroom
18:36:02 [admin] > admin
18:36:03 [admin] > admin
18:36:05 [admin] > admin
18:36:07 [admin] > admin
18:36:12 [admin] > ddfdf
18:36:12 [admin] > fdf
18:36:18 [admin] > 
18:36:22 [admin] > 
18:36:25 [admin] > 
18:36:26 [admin] > 
18:37:02  > [admin] leave chatroom
18:37:21 [admin] > admin
18:37:23 [admin] > admin
18:37:24 [admin] > admin
18:37:26 [admin] > dd
18:37:27 [admin] > 
18:37:31 [admin] > 
18:37:35  > [admin] leave chatroom
18:38:27 [admin] > admin
18:38:29 [admin] > admin
18:38:29 [admin] > admin
18:38:32 [admin] > admin
18:38:33 [admin] > admin
18:38:34 [admin] > admin
18:38:36 [admin] > adminadmin
18:38:37 [admin] > 
18:38:43 [admin] > admin
18:38:46 [admin] > admin
18:52:56  > [admin] leave chatroom
18:54:25 [admin] > dsdsd
18:54:28 [admin] > ssss
18:54:34 [admin] > fdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdf
18:54:38 [admin] > try(BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()))) {
18:54:38 [admin] > 
18:54:38 [admin] >                 String serverMessage;
18:54:38 [admin] > //todo when server die
18:54:38 [admin] >                 while (client.isConnected()) {
18:54:38 [admin] >                         serverMessage = in.readLine();
18:54:38 [admin] >                     if (serverMessage != null) {
18:54:38 [admin] >                         System.out.println((char) 27 + "[34m" + serverMessage);
18:54:38 [admin] >                         if (serverMessage.equalsIgnoreCase("quit")) {
18:54:38 [admin] >                             break;
18:54:38 [admin] >                         }
18:54:38 [admin] >                     }
18:54:38 [admin] >                 }
18:54:38 [admin] >             } catch (IOException e) {
18:54:38 [admin] >                 e.printStackTrace();
18:54:38 [admin] >             }
18:54:46 [admin] > try(BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()))) {
18:54:46 [admin] > 
18:54:46 [admin] >                 String serverMessage;
18:54:46 [admin] > //todo when server die
18:54:46 [admin] >                 while (client.isConnected()) {
18:54:46 [admin] >                         serverMessage = in.readLine();
18:54:46 [admin] >                     if (serverMessage != null) {
18:54:46 [admin] >                         System.out.println((char) 27 + "[34m" + serverMessage);
18:54:46 [admin] >                         if (serverMessage.equalsIgnoreCase("quit")) {
18:54:46 [admin] >                             break;
18:54:46 [admin] >                         }
18:54:46 [admin] >                     }
18:54:46 [admin] >                 }
18:54:46 [admin] >             } catch (IOException e) {
18:54:46 [admin] >                 e.printStackTrace();
18:54:46 [admin] >             }
18:54:52 [admin] > 
18:54:53 [admin] > 
18:55:54  > [admin] leave chatroom
18:56:17 [admin] > d
18:56:18 [admin] > ddd
18:56:19 [admin] > ddg
18:56:31  > [admin] leave chatroom
18:59:09 [admin] > Hello
18:59:12 [admin] > ff
18:59:54 [user] > Hi
19:00:00 [admin] > hhhh
19:02:53 [admin] > package view;
19:02:53 [admin] > 
19:02:53 [admin] > import controller.Client;
19:02:53 [admin] > 
19:02:53 [admin] > import javax.swing.*;
19:02:53 [admin] > import java.awt.*;
19:02:53 [admin] > import java.awt.event.KeyEvent;
19:02:53 [admin] > import java.awt.event.KeyListener;
19:02:53 [admin] > import java.io.BufferedReader;
19:02:53 [admin] > import java.io.IOException;
19:02:53 [admin] > import java.io.InputStreamReader;
19:02:53 [admin] > import java.util.Observable;
19:02:53 [admin] > import java.util.Observer;
19:02:53 [admin] > 
19:02:53 [admin] > /**
19:02:53 [admin] >  * Created by Vorobiei on 17.03.2016.
19:02:53 [admin] >  */
19:02:53 [admin] > public class MainFrame extends JFrame implements Observer{
19:02:53 [admin] >     JMenuBar menuBar;
19:02:53 [admin] >     private static final long serialVersionId = 1L;
19:02:53 [admin] >     private static final int WIDTH = 600;
19:02:53 [admin] >     private static final int HEIGHT = 350;
19:02:53 [admin] >     private MainPanel mainPanel;
19:02:53 [admin] >     private Client client;
19:02:53 [admin] > 
19:02:53 [admin] >     public MainFrame() {
19:02:53 [admin] >         super("ArtChat");
19:02:53 [admin] >         setMinimumSize(new Dimension(WIDTH, HEIGHT));
19:02:53 [admin] >         setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
19:02:53 [admin] >         setLocationRelativeTo(null);
19:02:53 [admin] >         menuBar = new MenuBar();
19:02:53 [admin] >         setJMenuBar(menuBar);
19:02:53 [admin] >         this.mainPanel = new MainPanel();
19:02:53 [admin] >         add(mainPanel);
19:02:53 [admin] >         setVisible(true);
19:02:53 [admin] >         try {
19:02:53 [admin] >             this.client = new Client();
19:02:53 [admin] >         } catch (IOException e) {
19:02:53 [admin] >             e.printStackTrace();
19:02:53 [admin] >             Object[] options = {"Ok", "More..."};
19:02:53 [admin] >             int code = JOptionPane.showOptionDialog(this,
19:02:53 [admin] >                     "Can't connect to the server",
19:02:53 [admin] >                     "Connection error",
19:02:53 [admin] >                     JOptionPane.YES_NO_OPTION,
19:02:53 [admin] >                     JOptionPane.ERROR_MESSAGE, null, options, options[0]);
19:02:53 [admin] >             System.out.println(code);
19:02:53 [admin] >             if(code == 1){
19:02:53 [admin] >                 new ErrorFrame(this, e.getMessage());
19:02:53 [admin] >             }
19:02:53 [admin] >         }
19:02:53 [admin] >         boolean isLogIn = false;
19:02:53 [admin] >         BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
19:02:53 [admin] >         while (!isLogIn){
19:02:53 [admin] >             try {
19:02:53 [admin] >                 System.out.println("Enter login");
19:02:53 [admin] >                 String login = reader.readLine();
19:02:53 [admin] >                 System.out.println("Enter pass");
19:02:53 [admin] >                 String pass = reader.readLine();
19:02:53 [admin] >                 isLogIn = client.logIn(login, pass);
19:02:53 [admin] >             } catch (IOException e) {
19:02:53 [admin] >                 e.printStackTrace();
19:02:53 [admin] >             }
19:02:53 [admin] >         }
19:02:53 [admin] >         System.out.println("Log in");
19:02:53 [admin] >         try {
19:02:53 [admin] >             client.startChat(this);
19:02:53 [admin] >         } catch (IOException e) {
19:02:53 [admin] >             e.printStackTrace();
19:02:53 [admin] >         }
19:02:53 [admin] >         mainPanel.getSendButton().addActionListener(e -> {
19:02:53 [admin] >             sendMessage();
19:02:53 [admin] >         });
19:02:53 [admin] > 
19:02:53 [admin] >         mainPanel.getSendMessageArea().addKeyListener(new KeyListener() {
19:02:53 [admin] >             @Override
19:02:53 [admin] >             public void keyTyped(KeyEvent e) {
19:02:53 [admin] > 
19:02:53 [admin] >             }
19:02:53 [admin] > 
19:02:53 [admin] >             @Override
19:02:53 [admin] >             public void keyPressed(KeyEvent e) {
19:02:53 [admin] >                 if ((e.getKeyCode() == KeyEvent.VK_ENTER)
19:02:53 [admin] >                         && ((e.getModifiers() & KeyEvent.SHIFT_MASK) != 0)) {
19:02:53 [admin] >                     mainPanel.getSendMessageArea().append("\n");
19:02:53 [admin] >                     return;
19:02:53 [admin] >                 }
19:02:53 [admin] >                 if(e.getKeyCode() == KeyEvent.VK_ENTER){
19:02:53 [admin] >                     sendMessage();
19:02:53 [admin] >                 }
19:02:53 [admin] >             }
19:02:53 [admin] > 
19:02:53 [admin] >             @Override
19:02:53 [admin] >             public void keyReleased(KeyEvent e) {
19:02:53 [admin] >             }
19:02:53 [admin] >         });
19:02:53 [admin] >     }
19:02:53 [admin] > 
19:02:53 [admin] >     private void sendMessage() {
19:02:53 [admin] >         client.send(mainPanel.getSendMessageArea().getText().trim());
19:02:53 [admin] >         mainPanel.getSendMessageArea().setText("");
19:02:53 [admin] >     }
19:02:53 [admin] > 
19:02:53 [admin] >     public String writeMessage(){
19:02:53 [admin] >         return mainPanel.getSendMessageArea().getText();
19:02:53 [admin] >     }
19:02:53 [admin] > 
19:02:53 [admin] >     @Override
19:02:53 [admin] >     public void update(Observable o, Object arg) {
19:02:53 [admin] >         mainPanel.getReceiveMessages().append(arg + "\n");
19:02:53 [admin] >     }
19:02:53 [admin] > }
19:08:08  > [user] leave chatroom
19:08:21  > [admin] leave chatroom
19:08:56 [admin] > sdsdsdsdsds
19:09:00 [admin] > sdsd
19:09:03 [admin] > dsd
19:09:04 [admin] > 
19:09:07 [admin] > sdsdsdsd
19:09:13 [admin] > package view;
19:09:13 [admin] > 
19:09:13 [admin] > import controller.Client;
19:09:13 [admin] > 
19:09:13 [admin] > import javax.swing.*;
19:09:13 [admin] > import java.awt.*;
19:09:13 [admin] > import java.awt.event.KeyEvent;
19:09:13 [admin] > import java.awt.event.KeyListener;
19:09:13 [admin] > import java.io.BufferedReader;
19:09:13 [admin] > import java.io.IOException;
19:09:13 [admin] > import java.io.InputStreamReader;
19:09:13 [admin] > import java.util.Observable;
19:09:13 [admin] > import java.util.Observer;
19:09:13 [admin] > 
19:09:13 [admin] > /**
19:09:13 [admin] >  * Created by Vorobiei on 17.03.2016.
19:09:13 [admin] >  */
19:09:13 [admin] > public class MainFrame extends JFrame implements Observer{
19:09:13 [admin] >     JMenuBar menuBar;
19:09:13 [admin] >     private static final long serialVersionId = 1L;
19:09:13 [admin] >     private static final int WIDTH = 600;
19:09:13 [admin] >     private static final int HEIGHT = 350;
19:09:13 [admin] >     private MainPanel mainPanel;
19:09:13 [admin] >     private Client client;
19:09:13 [admin] > 
19:09:13 [admin] >     public MainFrame() {
19:09:13 [admin] >         super("ArtChat");
19:09:13 [admin] >         setMinimumSize(new Dimension(WIDTH, HEIGHT));
19:09:13 [admin] >         setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
19:09:13 [admin] >         setLocationRelativeTo(null);
19:09:13 [admin] >         menuBar = new MenuBar();
19:09:13 [admin] >         setJMenuBar(menuBar);
19:09:13 [admin] >         this.mainPanel = new MainPanel();
19:09:13 [admin] >         add(mainPanel);
19:09:13 [admin] >         setVisible(true);
19:09:13 [admin] >         try {
19:09:13 [admin] >             this.client = new Client();
19:09:13 [admin] >         } catch (IOException e) {
19:09:13 [admin] >             e.printStackTrace();
19:09:13 [admin] >             Object[] options = {"Ok", "More..."};
19:09:13 [admin] >             int code = JOptionPane.showOptionDialog(this,
19:09:13 [admin] >                     "Can't connect to the server",
19:09:13 [admin] >                     "Connection error",
19:09:13 [admin] >                     JOptionPane.YES_NO_OPTION,
19:09:13 [admin] >                     JOptionPane.ERROR_MESSAGE, null, options, options[0]);
19:09:13 [admin] >             System.out.println(code);
19:09:13 [admin] >             if(code == 1){
19:09:13 [admin] >                 new ErrorFrame(this, e.getMessage());
19:09:13 [admin] >             }
19:09:13 [admin] >         }
19:09:13 [admin] >         boolean isLogIn = false;
19:09:13 [admin] >         BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
19:09:13 [admin] >         while (!isLogIn){
19:09:13 [admin] >             try {
19:09:13 [admin] >                 System.out.println("Enter login");
19:09:13 [admin] >                 String login = reader.readLine();
19:09:13 [admin] >                 System.out.println("Enter pass");
19:09:13 [admin] >                 String pass = reader.readLine();
19:09:13 [admin] >                 isLogIn = client.logIn(login, pass);
19:09:13 [admin] >             } catch (IOException e) {
19:09:13 [admin] >                 e.printStackTrace();
19:09:13 [admin] >             }
19:09:13 [admin] >         }
19:09:13 [admin] >         System.out.println("Log in");
19:09:13 [admin] >         try {
19:09:13 [admin] >             client.startChat(this);
19:09:13 [admin] >         } catch (IOException e) {
19:09:13 [admin] >             e.printStackTrace();
19:09:13 [admin] >         }
19:09:13 [admin] >         mainPanel.getSendButton().addActionListener(e -> {
19:09:13 [admin] >             sendMessage();
19:09:13 [admin] >         });
19:09:13 [admin] > 
19:09:13 [admin] >         mainPanel.getSendMessageArea().addKeyListener(new KeyListener() {
19:09:13 [admin] >             @Override
19:09:13 [admin] >             public void keyTyped(KeyEvent e) {
19:09:13 [admin] > 
19:09:13 [admin] >             }
19:09:13 [admin] > 
19:09:13 [admin] >             @Override
19:09:13 [admin] >             public void keyPressed(KeyEvent e) {
19:09:13 [admin] >                 if ((e.getKeyCode() == KeyEvent.VK_ENTER)
19:09:13 [admin] >                         && ((e.getModifiers() & KeyEvent.SHIFT_MASK) != 0)) {
19:09:13 [admin] >                     mainPanel.getSendMessageArea().append("\n");
19:09:13 [admin] >                     return;
19:09:13 [admin] >                 }
19:09:13 [admin] >                 if(e.getKeyCode() == KeyEvent.VK_ENTER){
19:09:13 [admin] >                     sendMessage();
19:09:13 [admin] >                 }
19:09:13 [admin] >             }
19:09:13 [admin] > 
19:09:13 [admin] >             @Override
19:09:13 [admin] >             public void keyReleased(KeyEvent e) {
19:09:13 [admin] >             }
19:09:13 [admin] >         });
19:09:13 [admin] >     }
19:09:13 [admin] > 
19:09:13 [admin] >     private void sendMessage() {
19:09:13 [admin] >         client.send(mainPanel.getSendMessageArea().getText().trim());
19:09:13 [admin] >         mainPanel.getSendMessageArea().setText("");
19:09:13 [admin] >     }
19:09:13 [admin] > 
19:09:13 [admin] >     public String writeMessage(){
19:09:13 [admin] >         return mainPanel.getSendMessageArea().getText();
19:09:13 [admin] >     }
19:09:13 [admin] > 
19:09:13 [admin] >     @Override
19:09:13 [admin] >     public void update(Observable o, Object arg) {
19:09:13 [admin] >         mainPanel.getReceiveMessages().append(arg + "\n");
19:09:13 [admin] >     }
19:09:13 [admin] > }
19:12:16  > [admin] leave chatroom
19:12:20  > null leave chatroom
19:12:46 [admin] > fff
19:12:47 [admin] > dfdf
19:12:54 [admin] > package controller;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.reflect.TypeToken;import model.Message;import model.User;import privious.utils.IOUtils;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.util.*;import java.util.concurrent.*;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by gorobec on 20.03.16. */public class Server {    private static final String HISTORY_PATH = "src/main/resources/history.txt";    private static final String REGISTER_USERS_PATH = "src/main/resources/RegisterUsers.json";    private static final int PORT = 5555;//    todo connection limit    private static final int CONNECTION_LIMIT = 3;    private static final int USER_SERVER_SOCKET_PORT = 6789;    private final Lock lock = new ReentrantLock();    private ServerSocket server;    private ServerSocket userSaverSocket;    private Set<User> users;//    todo history    private List<Message> history;    private ExecutorService executorService;    private Set<Connection> clients = Collections.synchronizedSet(new HashSet<>());    private BlockingDeque<Message> messages = new LinkedBlockingDeque<>();    private Writer historyWriter;    public Server(){        executorService = Executors.newFixedThreadPool(5);        try {            this.server = new ServerSocket(PORT, CONNECTION_LIMIT);            this.userSaverSocket = new ServerSocket(USER_SERVER_SOCKET_PORT);            this.historyWriter = new FileWriter(HISTORY_PATH, true);        } catch (IOException e) {            System.err.println("Can't connect to the port");            e.printStackTrace();        }        history = new ArrayList<>();    }    public void start () throws IOException, ExecutionException, InterruptedException {        new Thread(() -> {            //noinspection InfiniteLoopStatement            while (true) {                    try {                        Message message = messages.take();                        for (Connection client : clients) {                            client.writer.println(message);                            client.writer.flush();                        }                        historyWriter.write(message.toString() + "\n");                        historyWriter.flush();                        history.add(message);                        for (Message message1 : history) {                            System.out.println(message1);                        }                    } catch (InterruptedException | IOException e) {                        e.printStackTrace();                    }            }        }).start();        //noinspection InfiniteLoopStatement        while (true){            System.out.println("Server waiting for new clients...");            Socket client = server.accept();            Connection connection = new Connection(client);//            todo threadPool            executorService.submit(connection);        }    }    private boolean checkUser(User user) {        lock.lock();        try {            this.users = new Gson().fromJson(new FileReader(REGISTER_USERS_PATH), new TypeToken<Set<User>>() {            }.getType());        } catch (FileNotFoundException e) {            e.printStackTrace();        } finally {            lock.unlock();        }        return users.contains(user);    }    private class Connection extends Thread{        private Socket client;        private User user;        private InputStream is;        private OutputStream os;        private ObjectInputStream ois;        private DataOutputStream oos;        private BufferedReader in;        private PrintWriter writer;        public Connection (Socket socket) {            this.client = socket;            try {                this.is = client.getInputStream();                this.os = client.getOutputStream();                oos = new DataOutputStream(os);                ois = new ObjectInputStream(is);            } catch (IOException e) {                e.printStackTrace();            }        }        public void run () {            Thread recorder = new RegistrationThread();            try {                while (client.isConnected()) {                    user = (User) ois.readObject();                    boolean isRegister = checkUser(user);//                    todo if logIn twice                    oos.writeBoolean(isRegister);                    if (isRegister) break;                }                recorder.interrupt();                if(client.isConnected()) {                    clients.add(this);//                    messages.put(new Message(String.format("%s connect to the chatroom", user)));                    writer = new PrintWriter(client.getOutputStream());                    writer.println(new Message("Welcome to the \"Artchat\"! Write your message..."));                    writer.flush();                    in = new BufferedReader                            (new InputStreamReader(client.getInputStream()));                    while (client.isConnected()) {//                        locked method, wait for client message                        String receivedText;                        receivedText = in.readLine();                        while (in.ready()){                            receivedText += in.readLine();                        }//                        if client disconnect while server waits for message//                        client send null                        if(receivedText == null) {                            break;                        }                        Message message = new Message(user, receivedText);                        messages.put(message);                    }                }            } catch (InterruptedException | IOException | ClassNotFoundException e) {                e.printStackTrace();            } finally {                try {                    clients.remove(this);                    messages.put(new Message(String.format("%s leave chatroom", user)));                    close();                } catch (InterruptedException ignore) {                   /*NOP*/                }            }        }        private void close() {            try {                IOUtils.closeIn(client.getInputStream());                IOUtils.closeOut(client.getOutputStream());                client.close();            } catch (IOException e) {                System.out.println("Client socket closed");            }        }    }//  todo registration on website    private class RegistrationThread extends Thread{        private Socket userClient;        private InputStream is;        private OutputStream os;        private DataOutputStream dos;        private ObjectInputStream ois;        public RegistrationThread() {            start();        }        @Override        public void run() {            try{                this.userClient = userSaverSocket.accept();                this.is = userClient.getInputStream();                this.os = userClient.getOutputStream();                this.dos = new DataOutputStream(os);                this.ois = new ObjectInputStream(is);                //noinspection LoopStatementThatDoesntLoop                while (userClient.isConnected()) {                        User user = (User) ois.readObject();                        boolean isAlreadyRegister = checkUser(user);//                    todo if logIn twice                        if(!isAlreadyRegister){                            dos.writeBoolean(register(user));                            dos.flush();                            break;                        }                        dos.writeBoolean(false);                        dos.flush();                        break;                }            } catch (IOException | ClassNotFoundException e) {                    e.printStackTrace();            }        }        private boolean register(User user) {            Gson gson = new GsonBuilder().setPrettyPrinting().create();            String result = "";            try {                BufferedReader reader = new BufferedReader(new FileReader(REGISTER_USERS_PATH));                while (reader.ready()){                    result += reader.readLine() + "\n";                }                Set<User> users = gson.fromJson(result, new TypeToken<Set<User>>() {                }.getType());                if(!users.contains(user)) {                    users.add(user);//                    rewrite file with register users info//                    todo append to JSON file                    //noinspection ResultOfMethodCallIgnored                    new File(REGISTER_USERS_PATH).delete();                    Writer writer = new BufferedWriter(new FileWriter(REGISTER_USERS_PATH, true));                    gson.toJson(users, writer);                    writer.flush();                    return true;                }            } catch (IOException e) {                e.printStackTrace();            }            return false;        }    }}
19:14:20 [admin] > vv
19:14:23 [admin] > package controller;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import model.Message;
import model.User;
import privious.utils.IOUtils;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by gorobec on 20.03.16.
 */
public class Server {
    private static final String HISTORY_PATH = "src/main/resources/history.txt";
    private static final String REGISTER_USERS_PATH = "src/main/resources/RegisterUsers.json";
    private static final int PORT = 5555;
//    todo connection limit
    private static final int CONNECTION_LIMIT = 3;
    private static final int USER_SERVER_SOCKET_PORT = 6789;
    private final Lock lock = new ReentrantLock();
    private ServerSocket server;
    private ServerSocket userSaverSocket;
    private Set<User> users;
//    todo history
    private List<Message> history;
    private ExecutorService executorService;
    private Set<Connection> clients = Collections.synchronizedSet(new HashSet<>());
    private BlockingDeque<Message> messages = new LinkedBlockingDeque<>();
    private Writer historyWriter;


    public Server(){
        executorService = Executors.newFixedThreadPool(5);
        try {
            this.server = new ServerSocket(PORT, CONNECTION_LIMIT);
            this.userSaverSocket = new ServerSocket(USER_SERVER_SOCKET_PORT);
            this.historyWriter = new FileWriter(HISTORY_PATH, true);
        } catch (IOException e) {
            System.err.println("Can't connect to the port");
            e.printStackTrace();
        }
        history = new ArrayList<>();
    }

    public void start () throws IOException, ExecutionException, InterruptedException {
        new Thread(() -> {
            //noinspection InfiniteLoopStatement
            while (true) {
                    try {
                        Message message = messages.take();
                        for (Connection client : clients) {
                            client.writer.println(message);
                            client.writer.flush();
                        }
                        historyWriter.write(message.toString() + "\n");
                        historyWriter.flush();
                        history.add(message);
                        for (Message message1 : history) {
                            System.out.println(message1);
                        }
                    } catch (InterruptedException | IOException e) {
                        e.printStackTrace();
                    }
            }
        }).start();

        //noinspection InfiniteLoopStatement
        while (true){
            System.out.println("Server waiting for new clients...");
            Socket client = server.accept();
            Connection connection = new Connection(client);
//            todo threadPool
            executorService.submit(connection);
        }



    }
    private boolean checkUser(User user) {
        lock.lock();
        try {
            this.users = new Gson().fromJson(new FileReader(REGISTER_USERS_PATH), new TypeToken<Set<User>>() {
            }.getType());
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return users.contains(user);
    }


    private class Connection extends Thread{

        private Socket client;
        private User user;
        private InputStream is;
        private OutputStream os;
        private ObjectInputStream ois;
        private DataOutputStream oos;
        private BufferedReader in;
        private PrintWriter writer;

        public Connection (Socket socket) {
            this.client = socket;
            try {
                this.is = client.getInputStream();
                this.os = client.getOutputStream();
                oos = new DataOutputStream(os);
                ois = new ObjectInputStream(is);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        public void run () {

            Thread recorder = new RegistrationThread();
            try {
                while (client.isConnected()) {
                    user = (User) ois.readObject();
                    boolean isRegister = checkUser(user);
//                    todo if logIn twice
                    oos.writeBoolean(isRegister);
                    if (isRegister) break;
                }
                recorder.interrupt();
                if(client.isConnected()) {
                    clients.add(this);
//                    messages.put(new Message(String.format("%s connect to the chatroom", user)));
                    writer = new PrintWriter(client.getOutputStream());
                    writer.println(new Message("Welcome to the \"Artchat\"! Write your message..."));
                    writer.flush();
                    in = new BufferedReader
                            (new InputStreamReader(client.getInputStream()));

                    while (client.isConnected()) {
//                        locked method, wait for client message
                        String receivedText;
                        receivedText = in.readLine();
                        while (in.ready()){

                            receivedText += "\n" + in.readLine();
                        }
//                        if client disconnect while server waits for message
//                        client send null
                        if(receivedText == null) {
                            break;
                        }
                        Message message = new Message(user, receivedText);
                        messages.put(message);
                    }
                }
            } catch (InterruptedException | IOException | ClassNotFoundException e) {
                e.printStackTrace();
            } finally {
                try {
                    clients.remove(this);
                    messages.put(new Message(String.format("%s leave chatroom", user)));
                    close();
                } catch (InterruptedException ignore) {
                   /*NOP*/
                }
            }
        }

        private void close() {
            try {
                IOUtils.closeIn(client.getInputStream());
                IOUtils.closeOut(client.getOutputStream());
                client.close();
            } catch (IOException e) {
                System.out.println("Client socket closed");
            }
        }

    }
//  todo registration on website
    private class RegistrationThread extends Thread{
        private Socket userClient;
        private InputStream is;
        private OutputStream os;
        private DataOutputStream dos;
        private ObjectInputStream ois;

        public RegistrationThread() {
            start();
        }

        @Override
        public void run() {
            try{
                this.userClient = userSaverSocket.accept();
                this.is = userClient.getInputStream();
                this.os = userClient.getOutputStream();
                this.dos = new DataOutputStream(os);
                this.ois = new ObjectInputStream(is);
                //noinspection LoopStatementThatDoesntLoop
                while (userClient.isConnected()) {
                        User user = (User) ois.readObject();
                        boolean isAlreadyRegister = checkUser(user);
//                    todo if logIn twice

                        if(!isAlreadyRegister){
                            dos.writeBoolean(register(user));
                            dos.flush();
                            break;
                        }
                        dos.writeBoolean(false);
                        dos.flush();
                        break;
                }
            } catch (IOException | ClassNotFoundException e) {
                    e.printStackTrace();
            }
        }

        private boolean register(User user) {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            String result = "";
            try {
                BufferedReader reader = new BufferedReader(new FileReader(REGISTER_USERS_PATH));
                while (reader.ready()){
                    result += reader.readLine() + "\n";
                }
                Set<User> users = gson.fromJson(result, new TypeToken<Set<User>>() {
                }.getType());
                if(!users.contains(user)) {
                    users.add(user);
//                    rewrite file with register users info
//                    todo append to JSON file
                    //noinspection ResultOfMethodCallIgnored
                    new File(REGISTER_USERS_PATH).delete();
                    Writer writer = new BufferedWriter(new FileWriter(REGISTER_USERS_PATH, true));
                    gson.toJson(users, writer);
                    writer.flush();
                    return true;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            return false;
        }
    }
}
19:15:20 [admin] > hk
19:15:32  > [admin] leave chatroom
23:53:27  > [null] leave chatroom
23:54:29  > [admin] leave chatroom
23:56:15  > [admin] leave chatroom
23:57:58 [gorobec] > Hello!
23:58:07 [user] > Hi!
23:58:23 [admin] > Aloha!
23:58:59 [user] > package view.login_window;

import controller.Client;
import view.ErrorFrame;
import view.MainFrame;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;

/**
 * Created by gorobec on 03.04.16.
 */
public class LoginFrame extends JFrame {
    private static final int WIDTH = 628;
    private static final int HEIGHT =470;
    private GridBagLayout layout;
    private GridBagConstraints gbc;
    private JComboBox<String> login;
    private JPasswordField password;
    private JButton logInButton;
    private JLabel register;
    private JCheckBox autoLogIn;
    private Client client;
    public LoginFrame(){
        super("ArtChat login menu");
        setSize(WIDTH, HEIGHT);
        setResizable(false);
        setLocationRelativeTo(null);
        setAlwaysOnTop(true);
        this.layout = new GridBagLayout();
        this.layout.columnWidths = new int[]{319, 319};
        this.layout.rowHeights = new int[]{94, 94, 94, 94};
        this.gbc = new GridBagConstraints();
        setLayout(layout);


//        add loging ComboBox
        String[] names = {"admin", "user", "gorobec"};
        this.login = new JComboBox<>(names);
        login.setEditable(true);
        login.setMinimumSize(new Dimension(150, 35));
        gbc.gridy = 0;
        gbc.gridx = 0;
        gbc.gridwidth = 2;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.CENTER;
        layout.addLayoutComponent(login, gbc);

//        add password field
        this.password = new JPasswordField();
        password.setMinimumSize(new Dimension(150, 35));
        gbc.gridy = 1;
        layout.addLayoutComponent(password,gbc);

//        add login button
        this.logInButton = new JButton("Log in");
        logInButton.addActionListener(event ->{
            if(client.logIn((String)login.getSelectedItem(), new String(password.getPassword()))){
                new MainFrame(client);
                this.dispose();
            }
        });
        gbc.gridy = 2;
        layout.addLayoutComponent(logInButton, gbc);

//        add register label
        this.register = new JLabel("Register");
        register.setFont(new Font("Arial", Font.PLAIN, 16));
        gbc.gridy = 4;
        gbc.gridwidth = 1;
        gbc.fill = GridBagConstraints.LAST_LINE_START;
        gbc.insets = new Insets(50, 0, 0, 200);
        layout.addLayoutComponent(register, gbc);

//        add checkbox
        this.autoLogIn = new JCheckBox("Auto login");
        autoLogIn.setSelected(true);
        gbc.gridx = 1;
        gbc.fill = GridBagConstraints.LAST_LINE_END;
        gbc.insets = new Insets(50, 200, 0, 0);
        layout.addLayoutComponent(autoLogIn, gbc);

        add(login);
        add(password);
        add(logInButton);
        add(register);
        add(autoLogIn);
       try{
           client = new Client();
    } catch (IOException e) {
        e.printStackTrace();
        Object[] options = {"Ok", "More..."};
        int code = JOptionPane.showOptionDialog(this,
                "Can't connect to the server",
                "Connection error",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.ERROR_MESSAGE, null, options, options[0]);
        System.out.println(code);
        if(code == 1){
            new ErrorFrame(this, e.getMessage());
        }
    }
        setVisible(true);
    }
}
23:59:48 [user] > Olga
00:00:17 [user] > )))
00:01:06  > [user] leave chatroom
00:01:08  > [admin] leave chatroom
00:01:10  > [gorobec] leave chatroom
01:34:52  > null leave chatroom
01:35:58  > null leave chatroom
01:36:26  > null leave chatroom
01:36:48  > null leave chatroom
01:37:15  > null leave chatroom
01:37:31  > null leave chatroom
02:00:47  > null leave chatroom
02:01:01  > [admin] leave chatroom
02:01:36  > null leave chatroom
02:02:06  > null leave chatroom
02:02:11  > null leave chatroom
02:02:36  > null leave chatroom
02:03:16  > null leave chatroom
02:04:01  > null leave chatroom
02:04:14  > null leave chatroom
02:04:41  > null leave chatroom
02:05:49  > null leave chatroom
02:06:09  > null leave chatroom
02:06:39  > null leave chatroom
02:07:02  > null leave chatroom
02:07:27  > null leave chatroom
07:20:49  > [admin] leave chatroom
07:21:43  > [z] leave chatroom
07:22:03  > null leave chatroom
07:23:07  > null leave chatroom
15:43:07  > null leave chatroom
15:43:58  > null leave chatroom
15:44:44  > [admin] leave chatroom
